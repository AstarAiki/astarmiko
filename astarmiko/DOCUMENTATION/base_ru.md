***Основной модуль astarmiko***
Содержит классы Activka (базовый класс представления всего активного сетевого оборудования) и наследуемый ему ActivkaBackup (базовый класс для бэкапа конфигов оборудования)


***Инициализация класса Activka***
myactivka = Activka('activka_byname.yaml') где 'activka_byname.yaml' - файл в формате YAML хранящий информацию о всём оборудовании, (см. **activka_byname_ru.md**)

## Activka functions:

### choose(device, withoutname = False)
создает словарь для подключения в формате netmiko для использования с ConnectHandler(\*\*device), где device - имя устройства (из activka_byname.yaml) а withoutname - селектор выбора формата словаря {dictionary for conect} if False (default) или   {device_name:{dictionary for conect}} if True

### filter(device_type = None, levels = None, segment = None)
выбирает из activka_byname.yaml список устройств по трем параметрам
- device_type - тип устройства netmiko
- levels - 'R' - router
        'L3' - L3 swith
        'L2' - L2 switch
- segment - сегмент сети (см. **activka_byname_ru.md**)

### setconfig, getinfo, get_curr_config, list_of_all_ip_intf
Записать команды конфигурации на устройство, получить любую информацию (show commands), получить текущую конфигурацию, получить список всех IP интерфейсов

### setconfig_on_devices, execute_on_devices
Записать команды конфигурации сразу на множество устройств, получить любую информацию со множество устройств (show commands) 

## ActivkaBackup functions:

### \_setup_backup_servers
Я имею 2 сервера для хранения конфигураций оборудования (**main & second**) так как скрипт архивирования может запускаться на main server по cron'у и в этом случае для скрипта main  - это локальный сервер, доступ к каталогу с конфигами средствами ОС или его можно запустить со своей рабочей станции, и тогда main server так же как и second становится удаленным сервером и доступ к нему определяется через  
\_**setup_protocol_handlers** 

### compare_configs( device: str, ignore_lines: List[str] = None) -> Dict[str, Any]
сравнивает текущую конфигурацию устройства с последней сохраненной на сервере  и возвращает различия

### get_backup_config, write_backup
получает последний сохраненный конфиг из файла на сервере и создает файл на сервере и записывает в него текущую конфигурацию устройства, на эти функции мапируются _get_backup_config, _get_backup_config, _write_backup_scp, _write_backup_sftp

## Отдельные функции вне класса

### setup_logging
настройка уровня,  формата, назначения вывода  логгирования 

### setup_config
функция для настройки различных параметров работы модуля на основе конфигурационного файла в формате YAML

В качестве параметров может быть что угодно - пути для хранения файлов конфигураций, шаблонов, имена и пароли пользователей для доступа, включение, отключение, настройка логов, выбор языка интерфейса, создание словаря стандартных команд для различного типа используемого у вас оборудования

### snmp_get_oid
Видимо в будущем выполнение snmpget и подобного выведу в отдельный модуль, а пока эта функция потребовалась потому, что весь astarmiko написан на использовании ssh доступа к оборудованию, а в моей сети появилиссь файерволы российского производства Континент-4, которые не имеют полноценного CLI но которые являются маршрутизатором для определенных сегментов сети и arp и mac-address таблицы по ssh с них не получишь, только по snmp

### send_config_by_one, send_config_commands
послать одну или сразу список команд конфигурации на устройство

### send_show_command
Послать show команду на устройство

### port_name_normalize
Появление этой команды вызвано тем, что на устройствах Huawei нельзя вывод одной команды использовать для выполнения другой команды, устрройства Huawei, например возвращают в списке интерфейсов как GE0/0/1 а при вводе команд надо писать GI0/0/1

### get_port_by_mac
Функция ищет на каком порту "светится" устройство с определенным mac-address и является ли этот порт  конечным (за ним только это устройство или это устройство с IP телефоном), или же к порту подключен следующий в цепочке коммутатор

### convert_mac
В реальной жизни маршрутизатор может быть одного брэнда (и возвращающий ARP таблицу в одном формате) а коммутатор к нему подключенный другого бренда, и, чтобы на нем искать по mac адресу устройство, необходимо указывать это mac адрес в другом формате.

Эта функция знает к какому формату преобразовать mac-address основываясь на device_type и формате адреса, привязанном к этому device_type

### del_exeption
во многих коммутаторах фирмы Cisco в текущем конфиге может быть строка вида 'ntp clock-period *SOME-NUMBER*' где *SOME-NUMBER*' меняется и сравнение конфигов текущего и предыдущего всегда покажет что они различны, хотя это не так

### check_identity
сравнение двух конфигов на равнозначность

### templatizator
Функция преобразует вывод на консоль оборудования результата выполнения какой либо команды в список списков с помощью textFSM template.
Могут быть стандартные шаблоны для стандартных наиболее встречающихся команд и тогда функции достаточно передать только device_type, вывод на консоль и аббревиатуру стандартной команды (см. ***commands.md***) или же вместо абревиатуры стандартной команды можно передать флаг special = True (специальная, заранее не определенная команда) и имя файла шаблона для этой команды
